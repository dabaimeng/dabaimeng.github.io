<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【分子模拟】使用lammps模拟水在多孔二氧化硅中的吸附</title>
    <link href="/2025/08/15/%E4%BD%BF%E7%94%A8lammps%E6%A8%A1%E6%8B%9F%E6%B0%B4%E5%9C%A8%E5%A4%9A%E5%AD%94%E4%BA%8C%E6%B0%A7%E5%8C%96%E7%A1%85%E4%B8%AD%E7%9A%84%E5%90%B8%E9%99%84/"/>
    <url>/2025/08/15/%E4%BD%BF%E7%94%A8lammps%E6%A8%A1%E6%8B%9F%E6%B0%B4%E5%9C%A8%E5%A4%9A%E5%AD%94%E4%BA%8C%E6%B0%A7%E5%8C%96%E7%A1%85%E4%B8%AD%E7%9A%84%E5%90%B8%E9%99%84/</url>
    
    <content type="html"><![CDATA[<h3 id="水在二氧化硅中的吸附"><a href="#水在二氧化硅中的吸附" class="headerlink" title="水在二氧化硅中的吸附**"></a>水在二氧化硅中的吸附**</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>本教程的目的是模拟水在多孔二氧化硅中的吸附。首先构建一个包含多孔二氧化硅和水的体系，然后使用 LAMMPS 进行分子动力学模拟。最后，分析模拟结果，以了解水分子在二氧化硅孔隙中的行为。</p><h4 id="1-准备结构文件"><a href="#1-准备结构文件" class="headerlink" title="1. 准备结构文件"></a><strong>1. 准备结构文件</strong></h4><p>在开始模拟之前，需要准备两个结构文件：一个用于多孔二氧化硅，另一个用于水。</p><h5 id="1-1-多孔二氧化硅结构"><a href="#1-1-多孔二氧化硅结构" class="headerlink" title="1.1. 多孔二氧化硅结构"></a><strong>1.1. 多孔二氧化硅结构</strong></h5><p>首先，需要创建一个多孔二氧化硅结构。有多种方法可以做到这一点，这里使用 VMD 及其内置的无机物构建器。</p><ol><li>打开 VMD。</li><li>转到 <code>Extensions</code> -&gt; <code>Modeling</code> -&gt; <code>Inorganic Builder</code>。</li><li>在 <code>Material</code> 下拉菜单中选择 <code>Cristobalite</code> (方石英)。</li><li>设置晶胞参数，例如 <code>a=5.0</code>, <code>b=5.0</code>, <code>c=5.0</code>。</li><li>点击 <code>Create Unit Cell</code> (创建晶胞)。</li><li>现在，为了创建一个孔隙，可以删除一些原子。选择一些原子并删除它们。也可以使用 VMD 的 <code>Tk Console</code> (Tk 控制台) 来更精确地完成此操作。例如，要删除一个球体内的所有原子，可以使用以下命令：<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> sel [atomselect top <span class="hljs-string">&quot;within 2.0 (x y z)&quot;</span>]<br><span class="hljs-variable">$sel</span> delete<br></code></pre></td></tr></table></figure>这将删除以坐标 (x, y, z) 为中心、半径为 2.0 Å 的球体内的所有原子。</li><li>对结构满意后，将其保存为 <code>data.sio2</code> 文件。转到 <code>File</code> -&gt; <code>Save Data...</code>，然后选择 <code>LAMMPS Data</code> 格式。<br><strong>注意</strong>: 也可以使用其他软件（如 Avogadro 或 Materials Studio）来创建多孔二氧化硅结构。确保最终导出为 LAMMPS 可以读取的格式，例如 <code>.data</code> 文件。</li></ol><h5 id="1-2-水盒子"><a href="#1-2-水盒子" class="headerlink" title="1.2. 水盒子"></a><strong>1.2. 水盒子</strong></h5><p>接下来，需要创建一个水盒子。这里将使用 Packmol 软件来构建它。</p><ol><li>创建一个名为 <code>water.inp</code> 的输入文件，内容如下：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tolerance</span> <span class="hljs-number">2</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">filetype</span> xyz<br><span class="hljs-attribute">output</span> water.xyz<br><span class="hljs-attribute">structure</span> spc216.pdb<br>  <span class="hljs-attribute">number</span> <span class="hljs-number">1000</span><br>  <span class="hljs-attribute">inside</span> box <span class="hljs-number">0</span>. <span class="hljs-number">0</span>. <span class="hljs-number">0</span>. <span class="hljs-number">40</span>. <span class="hljs-number">40</span>. <span class="hljs-number">40</span>.<br><span class="hljs-attribute">end</span> structure<br></code></pre></td></tr></table></figure><ul><li><code>tolerance 2.0</code>: 设置分子间的最小距离。</li><li><code>filetype xyz</code>: 指定输出文件格式。</li><li><code>output water.xyz</code>: 指定输出文件名。</li><li><code>structure spc216.pdb</code>: 指定水分子模板文件（一个包含单个 SPC&#x2F;E 水分子的 PDB 文件）。</li><li><code>number 1000</code>: 指定要放置的水分子数量。</li><li><code>inside box ...</code>: 指定放置水分子的盒子尺寸。</li></ul></li><li>运行 Packmol：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">packmol &lt; water.inp<br></code></pre></td></tr></table></figure>这将生成一个名为 <code>water.xyz</code> 的文件。</li><li>现在，需要将 <code>water.xyz</code> 文件转换为 LAMMPS 的 <code>.data</code> 文件。可以使用 VMD 来完成此操作。<ul><li>在 VMD 中打开 <code>water.xyz</code> 文件。</li><li>打开 Tk Console (<code>Extensions</code> -&gt; <code>Tk Console</code>)。</li><li>输入以下命令：<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">topo readlammpsdata water.data<br>topo writelammpsdata water.data<br></code></pre></td></tr></table></figure>这将创建一个名为 <code>water.data</code> 的 LAMMPS 数据文件。</li></ul></li></ol><h5 id="1-3-合并结构"><a href="#1-3-合并结构" class="headerlink" title="1.3. 合并结构"></a><strong>1.3. 合并结构</strong></h5><p>现在有了 <code>data.sio2</code> 和 <code>water.data</code> 两个文件，需要将它们合并成一个单一的 LAMMPS 数据文件。这可以通过手动编辑或使用脚本来完成。关键点在于：</p><ul><li>将两个文件的原子坐标部分合并。</li><li>正确更新原子总数、原子类型数、键数等头部信息。</li><li>确保原子类型编号不冲突（例如，二氧化硅中的 Si 原子类型为 1，O 原子类型为 2，那么水中的 O 和 H 原子类型应从 3 和 4 开始）。<br>这个过程可能有些繁琐。一个更简单的方法是使用 LAMMPS 本身来组合它们，但为了本教程的简洁性，假设你已经手动或通过自定义脚本成功创建了一个名为 <code>system.data</code> 的最终数据文件。</li></ul><h4 id="2-LAMMPS-输入脚本"><a href="#2-LAMMPS-输入脚本" class="headerlink" title="2. LAMMPS 输入脚本"></a><strong>2. LAMMPS 输入脚本</strong></h4><p>现在，可以编写 LAMMPS 输入脚本了。脚本分成几个部分。</p><h5 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1. 初始化"></a><strong>2.1. 初始化</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lammps"># --- 初始化 ---<br>units           real<br>atom_style      full<br>boundary        p p p<br></code></pre></td></tr></table></figure><ul><li><code>units real</code>: 使用 <code>real</code> 单位制（Å, kcal&#x2F;mol, fs 等）。</li><li><code>atom_style full</code>: 使用 <code>full</code> 原子样式，因为它支持分子、键、角和电荷。</li><li><code>boundary p p p</code>: 在所有三个方向上使用周期性边界条件。</li></ul><h5 id="2-2-读取数据文件"><a href="#2-2-读取数据文件" class="headerlink" title="2.2. 读取数据文件"></a><strong>2.2. 读取数据文件</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lammps"># --- 读取数据 ---<br>read_data       system.data<br></code></pre></td></tr></table></figure><p>这会读取之前准备的 <code>system.data</code> 文件。</p><h5 id="2-3-力场设置"><a href="#2-3-力场设置" class="headerlink" title="2.3. 力场设置"></a><strong>2.3. 力场设置</strong></h5><p>使用 CLAYFF 力场来描述二氧化硅，使用 SPC&#x2F;E 力场来描述水。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lammps"># --- 力场设置 ---<br>pair_style      lj/cut/coul/long 12.0<br>pair_modify     mix arithmetic<br>kspace_style    pppm 1e-4<br># 二氧化硅 (CLAYFF)<br>pair_coeff      1 1 0.0      0.0      # Si-Si<br>pair_coeff      1 2 103033.252 3.302   # Si-O (二氧化硅)<br>pair_coeff      2 2 230400.0  3.166    # O-O (二氧化硅)<br># 水 (SPC/E)<br>pair_coeff      3 3 0.1553   3.166    # O-O (水)<br>pair_coeff      4 4 0.0      0.0      # H-H<br>pair_coeff      3 4 0.0      0.0      # O-H (水)<br># 二氧化硅-水相互作用<br>pair_coeff      1 3 103033.252 3.302   # Si-O (水)<br>pair_coeff      1 4 0.0      0.0      # Si-H<br>pair_coeff      2 3 230400.0  3.166    # O (二氧化硅)-O (水)<br>pair_coeff      2 4 0.0      0.0      # O (二氧化硅)-H<br># 键和角参数 (水)<br>bond_style      harmonic<br>angle_style     harmonic<br>bond_coeff      1 1000.0 1.0<br>angle_coeff     1 100.0 109.47<br></code></pre></td></tr></table></figure><ul><li><code>pair_style lj/cut/coul/long 12.0</code>: 使用 Lennard-Jones (LJ) 和长程库仑相互作用，截断半径为 12.0 Å。</li><li><code>pair_modify mix arithmetic</code>: 使用算术平均规则来混合不同原子类型的 LJ 参数。</li><li><code>kspace_style pppm 1e-4</code>: 使用 PPPM 算法计算长程库仑相互作用，精度为 1e-4。</li><li><code>pair_coeff</code>: 为不同原子类型对定义 LJ 参数 (ε, σ)。<strong>注意</strong>: 你需要根据你的 <code>system.data</code> 文件中的原子类型编号来调整这些系数。这里假设 <code>1=Si</code>, <code>2=O_sio2</code>, <code>3=O_water</code>, <code>4=H_water</code>。</li><li><code>bond_style</code> 和 <code>angle_style</code>: 定义键和角的势能函数为谐振子势。</li><li><code>bond_coeff</code> 和 <code>angle_coeff</code>: 为水分子定义键和角的力常数与平衡值。</li></ul><h5 id="2-4-能量最小化"><a href="#2-4-能量最小化" class="headerlink" title="2.4. 能量最小化"></a><strong>2.4. 能量最小化</strong></h5><p>在开始动力学模拟之前，需要最小化体系的能量，以消除任何不合理的原子重叠。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lammps"># --- 能量最小化 ---<br>min_style       cg<br>minimize        1.0e-4 1.0e-6 1000 10000<br></code></pre></td></tr></table></figure><ul><li><code>min_style cg</code>: 使用共轭梯度算法进行最小化。</li><li><code>minimize</code>: 设置最小化收敛标准。</li></ul><h5 id="2-5-平衡模拟"><a href="#2-5-平衡模拟" class="headerlink" title="2.5. 平衡模拟"></a><strong>2.5. 平衡模拟</strong></h5><p>现在，将对体系进行平衡，使其达到目标温度和压力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lammps"># --- 平衡 ---<br>reset_timestep  0<br>timestep        1.0<br># 速度初始化<br>velocity        all create 300.0 12345<br># NVT 平衡<br>fix             1 all nvt temp 300.0 300.0 100.0<br>thermo          100<br>thermo_style    custom step temp pe ke etotal press vol<br>run             10000<br>unfix           1<br># NPT 平衡<br>fix             1 all npt temp 300.0 300.0 100.0 iso 1.0 1.0 1000.0<br>run             20000<br>unfix           1<br></code></pre></td></tr></table></figure><ul><li><code>reset_timestep 0</code>: 将时间步重置为 0。</li><li><code>timestep 1.0</code>: 设置时间步长为 1 fs。</li><li><code>velocity all create 300.0 12345</code>: 根据随机数种子 12345，为所有原子赋予 300 K 的初始速度。</li><li><code>fix 1 all nvt ...</code>: 在 NVT（正则）系综下运行模拟，使用 Nosé-Hoover 恒温器将温度维持在 300 K。</li><li><code>thermo 100</code>: 每 100 步输出一次热力学信息。</li><li><code>thermo_style</code>: 自定义热力学输出的内容。</li><li><code>run 10000</code>: 运行 10000 步（10 ps）的 NVT 模拟。</li><li><code>fix 1 all npt ...</code>: 在 NPT（等温等压）系综下运行模拟，使用 Nosé-Hoover 恒温器和恒压器，将温度维持在 300 K，压力维持在 1 atm。</li><li><code>run 20000</code>: 运行 20000 步（20 ps）的 NPT 模拟。</li></ul><h5 id="2-6-生产模拟"><a href="#2-6-生产模拟" class="headerlink" title="2.6. 生产模拟"></a><strong>2.6. 生产模拟</strong></h5><p>体系平衡后，运行一个更长的生产模拟来收集数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lammps"># --- 生产模拟 ---<br>reset_timestep  0<br>fix             1 all npt temp 300.0 300.0 100.0 iso 1.0 1.0 1000.0<br># 输出轨迹<br>dump            1 all custom 1000 dump.lammpstrj id type x y z<br># 运行模拟<br>run             100000<br># 清理<br>undump          1<br>unfix           1<br>print           &quot;Simulation finished&quot;<br></code></pre></td></tr></table></figure><ul><li><code>dump 1 all custom 1000 dump.lammpstrj ...</code>: 每 1000 步将所有原子的坐标、类型和 ID 输出到一个名为 <code>dump.lammpstrj</code> 的轨迹文件中。</li><li><code>run 100000</code>: 运行 100000 步（100 ps）的生产模拟。</li><li><code>undump</code> 和 <code>unfix</code>: 在模拟结束时移除 <code>dump</code> 和 <code>fix</code> 命令，这是一个好习惯。</li></ul><h4 id="3-运行模拟"><a href="#3-运行模拟" class="headerlink" title="3. 运行模拟"></a><strong>3. 运行模拟</strong></h4><p>将上述所有部分保存到一个名为 <code>in.adsorption</code> 的文件中。然后，在终端中运行 LAMMPS：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lmp -<span class="hljs-keyword">in</span> in.adsorption<br></code></pre></td></tr></table></figure><p>模拟完成后，你将得到一个名为 <code>dump.lammpstrj</code> 的轨迹文件和一个名为 <code>log.lammps</code> 的日志文件。</p><h4 id="4-分析结果"><a href="#4-分析结果" class="headerlink" title="4. 分析结果"></a><strong>4. 分析结果</strong></h4><p>现在，可以分析模拟结果了。我们将使用 VMD 和一些自定义脚本来进行分析。</p><h5 id="4-1-可视化"><a href="#4-1-可视化" class="headerlink" title="4.1. 可视化"></a><strong>4.1. 可视化</strong></h5><p>使用 VMD 打开 <code>dump.lammpstrj</code> 文件，可视化水分子在二氧化硅孔隙中的运动和吸附行为。</p><h5 id="4-2-密度分布图"><a href="#4-2-密度分布图" class="headerlink" title="4.2. 密度分布图"></a><strong>4.2. 密度分布图</strong></h5><p>计算水分子沿 z 轴的密度分布，以观察水在孔隙中的富集情况。</p><ol><li>在 VMD 中加载轨迹文件。</li><li>打开 Tk Console。</li><li>运行以下 Tcl 脚本：<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> sel [atomselect top <span class="hljs-string">&quot;name O and type 3&quot;</span>] # 选择水中的氧原子<br><span class="hljs-keyword">set</span> nf [molinfo top get numframes]<br><span class="hljs-keyword">set</span> outfile [<span class="hljs-keyword">open</span> <span class="hljs-string">&quot;density_z.dat&quot;</span> w]<br><span class="hljs-keyword">puts</span> <span class="hljs-variable">$outfile</span> <span class="hljs-string">&quot;# z density&quot;</span><br><span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">set</span> i <span class="hljs-number">0</span>&#125; &#123;<span class="hljs-variable">$i</span> &lt; <span class="hljs-variable">$nf</span>&#125; &#123;<span class="hljs-keyword">incr</span> i&#125; &#123;<br>    <span class="hljs-variable">$sel</span> frame <span class="hljs-variable">$i</span><br>    <span class="hljs-keyword">set</span> z [<span class="hljs-variable">$sel</span> get z]<br>    <span class="hljs-keyword">set</span> z_bins [histogram <span class="hljs-variable">$z</span> -bins <span class="hljs-number">100</span> -min <span class="hljs-number">0</span> -max <span class="hljs-number">50</span>]<br>    <span class="hljs-keyword">puts</span> <span class="hljs-variable">$outfile</span> <span class="hljs-string">&quot;$z_bins&quot;</span><br>&#125;<br><span class="hljs-keyword">close</span> <span class="hljs-variable">$outfile</span><br></code></pre></td></tr></table></figure>这将生成一个名为 <code>density_z.dat</code> 的文件，其中包含沿 z 轴的密度数据。可以使用 Gnuplot 或 Python&#x2F;Matplotlib 对其进行绘图。</li></ol><h5 id="4-3-径向分布函数-RDF"><a href="#4-3-径向分布函数-RDF" class="headerlink" title="4.3. 径向分布函数 (RDF)"></a><strong>4.3. 径向分布函数 (RDF)</strong></h5><p>RDF 可以告诉我们水分子在二氧化硅表面的结构排布信息。</p><ol><li>在 VMD Tk Console 中运行：<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">set</span> sel1 [atomselect top <span class="hljs-string">&quot;name O and type 2&quot;</span>] # 选择二氧化硅中的氧原子<br><span class="hljs-keyword">set</span> sel2 [atomselect top <span class="hljs-string">&quot;name O and type 3&quot;</span>] # 选择水中的氧原子<br><span class="hljs-keyword">set</span> r [measure rdf <span class="hljs-variable">$sel1</span> <span class="hljs-variable">$sel2</span> -rmax <span class="hljs-number">10.0</span> -bins <span class="hljs-number">100</span> -useframe all -<span class="hljs-keyword">update</span> <span class="hljs-number">100</span>]<br><span class="hljs-keyword">set</span> outfile [<span class="hljs-keyword">open</span> <span class="hljs-string">&quot;rdf_oo.dat&quot;</span> w]<br><span class="hljs-keyword">foreach</span> &#123;r g_r&#125; <span class="hljs-variable">$r</span> &#123;<br>    <span class="hljs-keyword">puts</span> <span class="hljs-variable">$outfile</span> <span class="hljs-string">&quot;$r $g_r&quot;</span><br>&#125;<br><span class="hljs-keyword">close</span> <span class="hljs-variable">$outfile</span><br></code></pre></td></tr></table></figure>这将计算并输出二氧化硅氧原子与水氧原子之间的 RDF 到 <code>rdf_oo.dat</code> 文件中。</li></ol><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>本教程向你展示了如何模拟水在多孔二氧化硅中的吸附。涵盖了从准备结构、编写 LAMMPS 输入脚本到分析模拟结果的整个过程。可以通过修改体系（例如，改变孔隙大小、使用不同的表面或不同的液体）来扩展这个教程，以研究其他吸附体系。</p><hr>]]></content>
    
    
    <categories>
      
      <category>流体算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lammps模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【AI算法】手搓ChatGPT-采用Transformer架构构建大语言模型</title>
    <link href="/2025/03/29/%E6%89%8B%E6%90%93ChatGPT-%E9%87%87%E7%94%A8Transformer%E6%9E%B6%E6%9E%84%E6%9E%84%E5%BB%BA%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/03/29/%E6%89%8B%E6%90%93ChatGPT-%E9%87%87%E7%94%A8Transformer%E6%9E%B6%E6%9E%84%E6%9E%84%E5%BB%BA%E5%A4%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>以下是我从CSDN上找到的代码，用于学习。采用Transformer架构，构建一个0.03B的语言模型（有点标题党，参数比较少，不能称之为大模型了）。</p><h2 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -*- coding:UTF-8 -*- </span><br><span class="hljs-comment"># Author:DA BAIMENG</span><br><span class="hljs-comment"># Time:2025/2/7 10:25</span><br>import torch.nn as nn<br><br><span class="hljs-comment">#注意力机制</span><br>class ScaledDotProductAttention(nn.Module):<br>    def __init__(self, d_k):<br>        super(ScaledDotProductAttention, self).__init__()<br>        self.d_k = d_k<br><br>    def forward(self, q, k, v, attention_mask):<br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># q: [batch_size, n_heads, len_q, d_k]</span><br>        <span class="hljs-comment"># k: [batch_size, n_heads, len_k, d_k]</span><br>        <span class="hljs-comment"># v: [batch_size, n_heads, len_v, d_v]</span><br>        <span class="hljs-comment"># attn_mask: [batch_size, n_heads, seq_len, seq_len]</span><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># 计算每个Q与K的分数，计算出来的大小是 [batch_size, n_heads, len_q, len_q]</span><br>        scores = torch.matmul(q, k.transpose(-1, -2)) / np.sqrt(self.d_k)<br>        <span class="hljs-comment"># 把被mask的地方置为无限小，softmax之后基本就是0，也就对q不起作用</span><br>        scores.masked_fill_(attention_mask, -1e9)<br>        attn = nn.Softmax(dim=-1)(scores)<br>        <span class="hljs-comment"># 注意力后的大小 [batch_size, n_heads, len_q, d_v]</span><br>        context = torch.matmul(attn, v)<br>        <span class="hljs-built_in">return</span> context, attn<br></code></pre></td></tr></table></figure><h2 id="多头注意力机制"><a href="#多头注意力机制" class="headerlink" title="多头注意力机制"></a>多头注意力机制</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#多头注意力机制</span><br>class MultiHeadAttention(nn.Module):<br>    def __init__(self, d_model, n_heads, d_k, d_v):<br>        super(MultiHeadAttention, self).__init__()<br>        self.d_model = d_model<br>        self.n_heads = n_heads<br>        self.d_k = d_k<br>        self.d_v = d_v<br>        self.w_q = nn.Linear(d_model, d_k * n_heads, bias=False)<br>        self.w_k = nn.Linear(d_model, d_k * n_heads, bias=False)<br>        self.w_v = nn.Linear(d_model, d_v * n_heads, bias=False)<br>        self.fc = nn.Linear(n_heads * d_v, d_model, bias=False)<br>        self.layernorm = nn.LayerNorm(d_model)<br><br>    def forward(self, q, k, v, attention_mask):<br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># q: [batch_size, seq_len, d_model]</span><br>        <span class="hljs-comment"># k: [batch_size, seq_len, d_model]</span><br>        <span class="hljs-comment"># v: [batch_size, seq_len, d_model]</span><br>        <span class="hljs-comment"># attn_mask: [batch_size, seq_len, seq_len]</span><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># 记录原始值, 后续计算残差</span><br>        residual, batch_size = q, q.size(0)<br>        <span class="hljs-comment"># 先映射 q、k、v, 然后后分头</span><br>        <span class="hljs-comment"># q: [batch_size, n_heads, len_q, d_k]</span><br>        q = self.w_q(q).view(batch_size, -1, self.n_heads, self.d_k).transpose(1, 2)<br>        <span class="hljs-comment"># k: [batch_size, n_heads, len_k, d_k]</span><br>        k = self.w_k(k).view(batch_size, -1, self.n_heads, self.d_k).transpose(1, 2)<br>        <span class="hljs-comment"># v: [batch_size, n_heads, len_v(=len_k), d_v]</span><br>        v = self.w_v(v).view(batch_size, -1, self.n_heads, self.d_v).transpose(1, 2)<br>        <span class="hljs-comment"># attn_mask : [batch_size, n_heads, seq_len, seq_len]</span><br>        attention_mask = attention_mask.unsqueeze(1).repeat(1, self.n_heads, 1, 1)<br>        <span class="hljs-comment"># 点积注意力分数计算，  [batch_size, n_heads, len_q, d_v]</span><br>        context, attn = ScaledDotProductAttention(self.d_k)(q, k, v, attention_mask)<br>        <span class="hljs-comment"># context: [batch_size, len_q, n_heads * d_v]</span><br>        context = context.transpose(1, 2).reshape(batch_size, -1, self.n_heads * self.d_v)<br>        <span class="hljs-comment"># 还原为原始大小</span><br>        output = self.fc(context)<br>        <span class="hljs-comment"># LN + 残差计算</span><br>        <span class="hljs-built_in">return</span> self.layernorm(output + residual), attn<br></code></pre></td></tr></table></figure><h2 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#前馈神经网络</span><br>class PoswiseFeedForwardNet(nn.Module):<br>    def __init__(self, d_model, d_ff):<br>        super(PoswiseFeedForwardNet, self).__init__()<br>        self.fc = nn.Sequential(<br>            nn.Linear(d_model, d_ff, bias=False),<br>            nn.ReLU(),<br>            nn.Linear(d_ff, d_model, bias=False)<br>        )<br>        self.layernorm = nn.LayerNorm(d_model)<br><br>    def forward(self, inputs):<br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># inputs: [batch_size, seq_len, d_model]</span><br>        <span class="hljs-comment">##</span><br>        residual = inputs<br>        output = self.fc(inputs)<br>        <span class="hljs-comment"># # LN + 残差计算, [batch_size, seq_len, d_model]</span><br>        <span class="hljs-built_in">return</span> self.layernorm(output + residual)<br></code></pre></td></tr></table></figure><h2 id="解码层构建"><a href="#解码层构建" class="headerlink" title="解码层构建"></a>解码层构建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#解码层构建</span><br>class DecoderLayer(nn.Module):<br>    def __init__(self, d_model, n_heads, d_ff, d_k, d_v):<br>        super(DecoderLayer, self).__init__()<br>        <span class="hljs-comment"># 多头注意力层</span><br>        self.attention = MultiHeadAttention(d_model, n_heads, d_k, d_v)<br>        <span class="hljs-comment"># 前馈神经网络层</span><br>        self.pos_ffn = PoswiseFeedForwardNet(d_model, d_ff)<br><br>    def forward(self, inputs, attention_mask):<br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># inputs: [batch_size, seq_len, d_model]</span><br>        <span class="hljs-comment"># attention_mask: [batch_size, seq_len, seq_len]</span><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># outputs: [batch_size, seq_len, d_model]</span><br>        <span class="hljs-comment"># self_attn: [batch_size, n_heads, seq_len, seq_len]</span><br>        outputs, self_attn = self.attention(inputs, inputs, inputs, attention_mask)<br>        <span class="hljs-comment"># [batch_size, seq_len, d_model]</span><br>        outputs = self.pos_ffn(outputs)<br>        <span class="hljs-built_in">return</span> outputs, self_attn<br></code></pre></td></tr></table></figure><h2 id="解码器构建"><a href="#解码器构建" class="headerlink" title="解码器构建"></a>解码器构建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#解码器构建</span><br>class PositionalEncoding(nn.Module):<br>    def __init__(self, d_model, max_pos, device):<br>        super(PositionalEncoding, self).__init__()<br>        self.device = device<br>        self.pos_embedding = nn.Embedding(max_pos, d_model)<br><br>    def forward(self, inputs):<br>        seq_len = inputs.size(1)<br>        pos = torch.arange(seq_len, dtype=torch.long, device=self.device)<br>        <span class="hljs-comment"># [seq_len] -&gt; [batch_size, seq_len]</span><br>        pos = pos.unsqueeze(0).expand_as(inputs)<br>        <span class="hljs-built_in">return</span> self.pos_embedding(pos)<br><br>def get_attn_subsequence_mask(<span class="hljs-built_in">seq</span>, device):<br>    <span class="hljs-comment"># 注意力分数的大小是 [batch_size, n_heads, len_seq, len_seq]</span><br>    <span class="hljs-comment"># 所以这里要生成 [batch_size, len_seq, len_seq] 大小</span><br>    attn_shape = [seq.size(0), seq.size(1), seq.size(1)]<br>    <span class="hljs-comment"># 生成一个上三角矩阵</span><br>    subsequence_mask = np.triu(np.ones(attn_shape), k=1)<br>    subsequence_mask = torch.from_numpy(subsequence_mask).byte()<br>    subsequence_mask = subsequence_mask.to(device)<br>    <span class="hljs-built_in">return</span> subsequence_mask<br><br>def get_attn_pad_mask(attention_mask):<br>    batch_size, len_seq = attention_mask.size()<br>    attention_mask = attention_mask.data.eq(0).unsqueeze(1)<br>    <span class="hljs-comment"># 注意力分数的大小是 [batch_size, n_heads, len_q, len_q]</span><br>    <span class="hljs-comment"># 所以这里要转换成 [batch_size, len_seq, len_seq] 大小</span><br>    <span class="hljs-built_in">return</span> attention_mask.expand(batch_size, len_seq, len_seq)<br><br>class Decoder(nn.Module):<br>    def __init__(self, d_model, n_heads, d_ff, d_k, d_v, vocab_size, max_pos, n_layers, device):<br>        super(Decoder, self).__init__()<br>        self.device = device<br>        <span class="hljs-comment"># 将Token转为向量</span><br>        self.embedding = nn.Embedding(vocab_size, d_model)<br>        <span class="hljs-comment"># 位置编码</span><br>        self.pos_encoding = PositionalEncoding(d_model, max_pos, device)<br>        self.layers = nn.ModuleList([DecoderLayer(d_model, n_heads, d_ff, d_k, d_v) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n_layers)])<br><br>    def forward(self, inputs, attention_mask):<br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># inputs: [batch_size, seq_len]</span><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># [batch_size, seq_len, d_model]</span><br>        outputs = self.embedding(inputs) + self.pos_encoding(inputs)<br>        <span class="hljs-comment"># 上三角掩码，防止看到未来的信息， [batch_size, seq_len, seq_len]</span><br>        subsequence_mask = get_attn_subsequence_mask(inputs, self.device)<br>        <span class="hljs-keyword">if</span> attention_mask is not None:<br>            <span class="hljs-comment"># pad掩码 [batch_size, seq_len, seq_len]</span><br>            attention_mask = get_attn_pad_mask(attention_mask)<br>            <span class="hljs-comment"># [batch_size, seq_len, seq_len]</span><br>            attention_mask = torch.gt((attention_mask + subsequence_mask), <span class="hljs-number">0</span>)<br>        else:<br>            attention_mask = subsequence_mask.bool()<br>        # 计算每一层的结果<br>        self_attns = []<br>        for layer in self.layers:<br>            # outputs: [batch_size, seq_len, d_model],<br>            # self_attn: [batch_size, n_heads, seq_len, seq_len],<br>            outputs, self_attn = layer(outputs, attention_mask)<br>            self_attns.append(self_attn)<br>        return outputs, self_attns<br></code></pre></td></tr></table></figure><h2 id="GPT模型构建"><a href="#GPT模型构建" class="headerlink" title="GPT模型构建"></a>GPT模型构建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#GPT模型构建</span><br>class GPTModel(nn.Module):<br>    def __init__(self, d_model, n_heads, d_ff, d_k, d_v, vocab_size, max_pos, n_layers, device):<br>        super(GPTModel, self).__init__()<br>        <span class="hljs-comment"># 解码器</span><br>        self.decoder = Decoder(d_model, n_heads, d_ff, d_k, d_v, vocab_size, max_pos, n_layers, device)<br>        <span class="hljs-comment"># 映射为词表大小</span><br>        self.projection = nn.Linear(d_model, vocab_size)<br><br>    def forward(self, inputs, attention_mask=None):<br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># inputs: [batch_size, seq_len]</span><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-comment"># outputs: [batch_size, seq_len, d_model]</span><br>        <span class="hljs-comment"># self_attns: [n_layers, batch_size, n_heads, seq_len, seq_len]</span><br>        outputs, self_attns = self.decoder(inputs, attention_mask)<br>        <span class="hljs-comment"># [batch_size, seq_len, vocab_size]</span><br>        logits = self.projection(outputs)<br>        <span class="hljs-built_in">return</span> logits.view(-1, logits.size(-1)), self_attns<br><br><span class="hljs-comment"># import torch</span><br><br><span class="hljs-comment"># from model import GPTModel</span><br><br><br>def main():<br>    device = torch.device(<span class="hljs-string">&quot;cuda:0&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>    <span class="hljs-comment"># 模型参数</span><br>    model_param = &#123;<br>        <span class="hljs-string">&quot;d_model&quot;</span>: 768,  <span class="hljs-comment"># 嵌入层大小</span><br>        <span class="hljs-string">&quot;d_ff&quot;</span>: 2048,  <span class="hljs-comment"># 前馈神经网络大小</span><br>        <span class="hljs-string">&quot;d_k&quot;</span>: 64,  <span class="hljs-comment"># K 的大小</span><br>        <span class="hljs-string">&quot;d_v&quot;</span>: 64,  <span class="hljs-comment"># V 的大小</span><br>        <span class="hljs-string">&quot;n_layers&quot;</span>: 6,  <span class="hljs-comment"># 解码层的数量</span><br>        <span class="hljs-string">&quot;n_heads&quot;</span>: 8,  <span class="hljs-comment"># 多头注意力的头数</span><br>        <span class="hljs-string">&quot;max_pos&quot;</span>: 1800,  <span class="hljs-comment"># 位置编码的长度</span><br>        <span class="hljs-string">&quot;device&quot;</span>: device,  <span class="hljs-comment"># 设备</span><br>        <span class="hljs-string">&quot;vocab_size&quot;</span>: 4825  <span class="hljs-comment"># 词表大小</span><br>    &#125;<br>    model = GPTModel(**model_param)<br>    total_params = <span class="hljs-built_in">sum</span>(p.numel() <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> model.parameters())<br>    <span class="hljs-built_in">print</span>(model)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;total_params: &quot;</span>, total_params)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AI算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【自制仪器】制作一台接触角测试仪</title>
    <link href="/2025/03/28/%E3%80%90%E8%87%AA%E5%88%B6%E3%80%91%E5%88%B6%E4%BD%9C%E4%B8%80%E5%8F%B0%E6%8E%A5%E8%A7%A6%E8%A7%92%E6%B5%8B%E8%AF%95%E4%BB%AA/"/>
    <url>/2025/03/28/%E3%80%90%E8%87%AA%E5%88%B6%E3%80%91%E5%88%B6%E4%BD%9C%E4%B8%80%E5%8F%B0%E6%8E%A5%E8%A7%A6%E8%A7%92%E6%B5%8B%E8%AF%95%E4%BB%AA/</url>
    
    <content type="html"><![CDATA[<h1 id="制作一台接触角测试仪"><a href="#制作一台接触角测试仪" class="headerlink" title="制作一台接触角测试仪"></a>制作一台接触角测试仪</h1><p>为什么开始这项工作？<br>因为我们实验室的接触角采购自很多年前，配套软件的相关算法太落后了，只提供了一个类似于电子量角器的功能，需要手动画切线，读取角度。</p><p>而目前市面上大部分的接触角测试仪已经可以做到一键读取液滴基线并拟合接触角，通过调研，我觉得接触角测试算法实现并不困难（等我做了一段时间后发现还是挺难的），所以我想自己写一个接触角测试软件。</p><p>此外，软件写好后我发现，只需要接入一个相机，该软件就完全可以实现接触角从图像采集到数据分析的全过程。同时，我还加入了电机控制的部分，为我的这台接触角测试仪添加了自动进样的功能，目前样机已经做出来了。</p><p>下面展示软件效果和样机，样机委托深圳一家公司制作。</p><h2 id="硬件构成："><a href="#硬件构成：" class="headerlink" title="硬件构成："></a>硬件构成：</h2><p><img src="https://s21.ax1x.com/2025/03/28/pErU3Hs.jpg" alt="硬件构成"><br><img src="https://s21.ax1x.com/2025/03/28/pErakxU.jpg" width=606 height=406  alt="样机" /></p><h2 id="软件主要功能："><a href="#软件主要功能：" class="headerlink" title="软件主要功能："></a>软件主要功能：</h2><p>1、图像数据采集<br>2、液滴自动加样<br>3、液滴接触角一键测量<br>4、同时开发了手动基线测量、自动高宽法、三点法、五点法等接触角算法<br>5、添加了表面能计算模块<br>6、测试结果自动保存、一键导出报告</p><h2 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h2><p><img src="https://s21.ax1x.com/2025/03/28/pErdCeH.png" alt="自动边缘拟合读取接触角"><br><img src="https://s21.ax1x.com/2025/03/28/pErdPwd.png" alt="自动高宽法读取接触角"><br><img src="https://s21.ax1x.com/2025/03/28/pErdkFI.png" alt="手动三点法读取接触角"><br><img src="https://s21.ax1x.com/2025/03/28/pErdAYt.png" alt="手动五点法读取接触角"><br><img src="https://s21.ax1x.com/2025/03/28/pErdEfP.png" alt="生成报告"></p>]]></content>
    
    
    <categories>
      
      <category>硬件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【自制软件】多层系油藏数据管理软件</title>
    <link href="/2025/03/27/%E3%80%90%E8%87%AA%E5%88%B6%E8%BD%AF%E4%BB%B6%E3%80%91%E5%A4%9A%E5%B1%82%E7%B3%BB%E6%B2%B9%E8%97%8F%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/"/>
    <url>/2025/03/27/%E3%80%90%E8%87%AA%E5%88%B6%E8%BD%AF%E4%BB%B6%E3%80%91%E5%A4%9A%E5%B1%82%E7%B3%BB%E6%B2%B9%E8%97%8F%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>2021年参与了多层系油藏的开发，主要负责生产数据汇总分析，在此之前处理其他区块的数据主要依靠excel，但对于该区块，其叠合了三套层位，开发历史达20余年，井数也相对较多，分注合采。于是，我每周的工作基本上就是用excel处理一个百万行、数据量达千万规模的表格。效率极低，且excel经常卡退。对于一周就要更新一次的区块综合生产数据，每周都需要二到三天才能统计出来。</p><p>面对这样的问题，我觉得很有必要开发一个用于处理多层系油藏生产数据的软件，将我从繁重且乏味的数据统计工作中解放出来。软件最开始是以脚本的形式运行，后来为了是推广至其他区块，完善了相关的界面，经过前后一年多的编写及修改，目前已经形成了一套较为完善的多层系油藏生产数据分析软件。</p><p>单从生产数据统计这一任务来说，已经可以做到将原本需要三至四天的数据统计工作，压缩至10分钟，大大提高了工作效率。而且我在后期加入了生产动态分析的模块，可以随时查看任意井组的生产曲线。</p><p>下面是软件的具体内容（我为里面的部分模块写了说明书。）<br><img src="https://s21.ax1x.com/2025/03/28/pErcdBV.png" alt="软件界面"></p><p>此程序主要功能包括多层系油藏生产数据指标计算及注采反应曲线绘制等四个模块，具体实现功能如下：</p><p>（1） 综合生产数据统计及曲线绘制；<br>按照指定格式导入日生产数据后，软件可自动生成区块及各个层系的综合生产数据【月产液；月产油；月产水；日产液水平；日产油水平；平均单井日产液；平均单井日产油；含水率；开井数；月注水量；单井日注水量；日注水量；水井开井数】并生成 xls 文件，同时提供交互式曲线绘制功能。</p><p>（2） 产量构成统计及曲线绘制；<br>按照指定格式导入生产数据后，软件可自动计算区块及各个层系的产量构成数据，并生成 xlsx 文件，结果文件包括区块及各个层系的【本月产油；新井产量；措施增油量；老井产量】，可根据需要分别按月或按日计算产量构成。</p><p>（3） 递减率计算及曲线绘制；<br>导入以上两个模块生成的数据文件（综合生产数据.xlsx，月产量构成.xlsx），并设置标定时间，软件可自动计算区块及各个层系的递减率数据.xlsx 文件，结果文件包括区块及各个层系的【标定日产量；累计老井；累计措施；累计标定月产；综合递减率；自然递减率】。</p><p>（4） 多层系注采反应曲线绘制：<br>按照指定格式导入生产数据后。可批量绘制以水井为中心、以油井为中心的井组注采反应曲线，也可以自定义井组的方式进行绘制。该模块提供分层系绘制注采反应曲线的功能。</p><p>以下是我针对该程序部分模块编写的使用说明书：</p> <div class="row">    <embed src="/PDF01/first.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自制软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CFD算法】伪势LBM模拟相分离（python-numba加速）</title>
    <link href="/2025/03/26/%E4%BC%AA%E5%8A%BFLBM%E6%A8%A1%E5%9E%8B%E6%A8%A1%E6%8B%9F%E7%9B%B8%E5%88%86%E7%A6%BB%EF%BC%88python-numba%E5%8A%A0%E9%80%9F%EF%BC%89/"/>
    <url>/2025/03/26/%E4%BC%AA%E5%8A%BFLBM%E6%A8%A1%E5%9E%8B%E6%A8%A1%E6%8B%9F%E7%9B%B8%E5%88%86%E7%A6%BB%EF%BC%88python-numba%E5%8A%A0%E9%80%9F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟相分离（Python算法-Numba加速）"><a href="#模拟相分离（Python算法-Numba加速）" class="headerlink" title="模拟相分离（Python算法-Numba加速）"></a>模拟相分离（Python算法-Numba加速）</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定随机初始状态模拟两相分离的效果，结果如下：<br><img src="https://s21.ax1x.com/2025/03/28/pErN8fK.png" alt="分离过程"></p><h2 id="代码优化说明"><a href="#代码优化说明" class="headerlink" title="代码优化说明"></a>代码优化说明</h2><ul><li>原始Python循环较慢（200×200网格100循环步耗时166秒）</li><li>使用Numba优化后降至11秒</li><li>MATLAB参考实现仅需5.6秒（后续计划尝试Taichi加速）<br><img src="https://pica.zhimg.com/v2-6aaf2072e5b8eee66ec13a7b46e3b032_1440w.jpg" alt="优化结果"></li></ul><h2 id="Numba加速版代码"><a href="#Numba加速版代码" class="headerlink" title="Numba加速版代码"></a>Numba加速版代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -*- coding:UTF-8 -*-</span><br>from numpy import *<br>import numpy as np<br>import numba as nb<br>from numba import jit<br>from matplotlib import cm<br>import matplotlib.pyplot as plt<br><br><span class="hljs-comment"># 参数设置</span><br>lx, ly = 200, 200<br>w = [4/9, 1/9,1/9,1/9,1/9, 1/36,1/36,1/36,1/36]<br>cx = [0, 1, 0, -1, 0, 1, -1, -1, 1]<br>cy = [0, 0, 1, 0, -1, 1, 1, -1, -1]<br>tau, mstep = 1, 5000<br>G, psi0, rho0 = -140, 4, 200<br><br><span class="hljs-comment"># 初始化随机密度场</span><br>delta_rho = 200 + (1-2.0 * np.random.random((lx, ly)))<br><br><span class="hljs-comment"># 分配内存</span><br>u_x = zeros((lx,ly)); u_y = zeros((lx,ly))<br>u = zeros((lx,ly)); v = zeros((lx,ly))<br>ueq = zeros((lx,ly)); veq = zeros((lx,ly))<br>rho = zeros((lx,ly)); psi = zeros((lx,ly))<br>fin = zeros((<span class="hljs-number">9</span>,lx,ly)); feq = zeros((<span class="hljs-number">9</span>,lx,ly))<br>fout = zeros((<span class="hljs-number">9</span>,lx,ly))<br><br><span class="hljs-comment"># 初始分布函数</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(9):<br>    fin[k, :, :] = w[k] * delta_rho<br><br>@jit(nopython=True)<br>def uv(fin, rho, u, v, cx, cy):<br>    <span class="hljs-comment"># 计算宏观量（密度和速度）</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lx):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ly):<br>            rho[i,j] = fin[:,i,j].<span class="hljs-built_in">sum</span>()<br>            uSum = vSum = 0<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(9):<br>                uSum += fin[k,i,j] * cx[k]<br>                vSum += fin[k,i,j] * cy[k]<br>            u[i,j] = uSum / rho[i,j]<br>            v[i,j] = vSum / rho[i,j]<br>    <span class="hljs-built_in">return</span> rho, u, v<br><br>@jit(nopython=True)<br>def fxy(psi, rho):<br>    <span class="hljs-comment"># 计算势函数</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lx):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ly):<br>            psi[i,j] = 4 * exp(-rho0 / rho[i,j])<br>    <span class="hljs-built_in">return</span> psi<br><br>@jit(nopython=True)<br>def fff(ueq, veq, rho, fin, feq, fout, w, cx, cy):<br>    <span class="hljs-comment"># 计算分布函数</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lx):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ly):<br>            t1 = ueq[i,j]**2 + veq[i,j]**2<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(9):<br>                t2 = ueq[i,j]*cx[k] + veq[i,j]*cy[k]<br>                feq[k,i,j] = rho[i,j]*w[k]*(1 + 3*t2 + 4.5*t2**2 - 1.5*t1)<br>                fout[k,i,j] = fin[k,i,j] - (fin[k,i,j] - feq[k,i,j])/tau<br>    <span class="hljs-built_in">return</span> feq, fout<br><br><span class="hljs-comment"># 主循环</span><br><span class="hljs-keyword">for</span> counter <span class="hljs-keyword">in</span> range(mstep):<br>    rho, u, v = uv(fin, rho, u, v, nb.typed.List(cx), nb.typed.List(cy))<br>    psi = fxy(psi, rho)<br>    <br>    <span class="hljs-comment"># 计算外力</span><br>    Fx = Fy = zeros((lx,ly))<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(9):<br>        <span class="hljs-keyword">if</span> k != 0:<br>            shifted_psi = np.roll(np.roll(psi, cx[k], axis=0), cy[k], axis=1)<br>            Fx += G * psi * w[k] * shifted_psi * cx[k]<br>            Fy += G * psi * w[k] * shifted_psi * cy[k]<br>    <br>    <span class="hljs-comment"># 更新平衡速度</span><br>    ueq = u + Fx * tau / rho<br>    veq = v + Fy * tau / rho<br>    <br>    <span class="hljs-comment"># 碰撞和迁移</span><br>    feq, fout = fff(ueq, veq, rho, fin, feq, fout, <br>                   nb.typed.List(w), nb.typed.List(cx), nb.typed.List(cy))<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(9):<br>        fin[k,:,:] = np.roll(np.roll(fout[k,:,:], cx[k], axis=0), cy[k], axis=1)<br>    <br>    <span class="hljs-comment"># 可视化</span><br>    <span class="hljs-keyword">if</span> counter % 100 == 0:<br>        plt.imshow(rho, cmap=cm.bwr)<br>        plt.pause(0.01)<br>        plt.clf()<br></code></pre></td></tr></table></figure><p>为了方便代码的理解，再放一个没有优化的代码。</p><h2 id="未加速版python代码"><a href="#未加速版python代码" class="headerlink" title="未加速版python代码"></a>未加速版python代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -*- coding:UTF-8 -*- </span><br><span class="hljs-comment"># Author:DA BAIMENG</span><br><span class="hljs-comment"># Time:2023/10/26 11:20</span><br>from numpy import *<br>import numpy as np<br>from matplotlib import cm<br>import matplotlib.pyplot as plt<br><br>lx=200<br>ly=200<br>w  = [4/9, 1/9,1/9,1/9,1/9, 1/36,1/36,1/36,1/36]<br>cx = [  0,   1,  0, -1,  0,    1,  -1,  -1,   1]<br>cy = [  0,   0,  1,  0, -1,    1,   1,  -1,  -1]<br><br>tau=1<br>mstep=5000<br><br>G=-140<br>psi0=4<br>rho0=200<br><span class="hljs-comment"># delta_rho = 200+(1-2.0 * random.rand(lx))</span><br>delta_rho = 200+(1-2.0 * np.random.random((lx, ly)))<br><br><span class="hljs-comment">#初始化</span><br>u_x=zeros((lx,ly))<br>u_y=zeros((lx,ly))<br>u=zeros((lx,ly))<br>v=zeros((lx,ly))<br>ueq=zeros((lx,ly))<br>veq=zeros((lx,ly))<br>rho=zeros((lx,ly))<br><br>fin=zeros((<span class="hljs-number">9</span>,lx,ly))<br>feq=zeros((<span class="hljs-number">9</span>,lx,ly))<br>fout=zeros((<span class="hljs-number">9</span>,lx,ly))<br>psi=zeros((lx,ly))<br><br><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(9):<br>    fin[k, :, :] = w[k] * delta_rho<br><br><span class="hljs-keyword">for</span> counter <span class="hljs-keyword">in</span> range(mstep):<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lx):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ly):<br>            rho[i, j] = <span class="hljs-built_in">sum</span>(fin[:, i, j], axis=0)<br>            uSum = 0<br>            vSum = 0<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(9):<br>                uSum = uSum + fin[k, i, j] * cx[k]<br>                vSum = vSum + fin[k, i, j] * cy[k]<br>            u[i, j] = uSum / rho[i, j]<br>            v[i, j] = vSum / rho[i, j]<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lx):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ly):<br>            psi[i, j] = 4 * exp(-rho0 / rho[i, j])<br><br>    Fx = zeros((lx, ly))<br>    Fy = zeros((lx, ly))<br><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(9):<br>        <span class="hljs-keyword">if</span> k != 0:<br>            Fx = Fx + G * psi * w[k] * roll(roll(psi, cx[k], axis=0), cy[k], axis=1) * cx[k]<br>            Fy = Fy + G * psi * w[k] * roll(roll(psi, cx[k], axis=0), cy[k], axis=1) * cy[k]<br><br>    ueq = u + Fx * tau / rho<br>    veq = v + Fy * tau / rho<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lx):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ly):<br>            t1 = ueq[i, j] * ueq[i, j] + veq[i, j] * veq[i, j]<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(9):<br>                t2 = ueq[i, j] * cx[k] + veq[i, j] * cy[k]<br>                feq[k, i, j] = rho[i, j] * w[k] * (1 + 3 * t2 + 4.5 * t2 * t2 - 1.5 * t1)<br>                fout[k, i, j] = fin[k, i, j] - 1 / tau * (fin[k, i, j] - feq[k, i, j])<br><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(9):<br>        fin[k, :, :] = roll(roll(fout[k, :, :], cx[k], axis=0), cy[k], axis=1)<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s / %s&#x27;</span> %(counter,mstep))<br><br>    plt.imshow(rho, cmap=cm.bwr)  <span class="hljs-comment"># 绘制密度场</span><br>    <span class="hljs-comment"># 不显示图形</span><br>    plt.ioff()<br>    <span class="hljs-comment"># 更新图形</span><br>    plt.pause(0.01)<br>    <span class="hljs-comment"># plt.savefig(r&quot;./计算结果/&quot; + str(counter) + &quot;.png&quot;)</span><br>    plt.clf()<br></code></pre></td></tr></table></figure><h2 id="matlab版代码"><a href="#matlab版代码" class="headerlink" title="matlab版代码"></a>matlab版代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs bash">clear<br>clc<br><br>lx=200;<br>ly=200;<br>w = [4/9, 1/9,1/9,1/9,1/9, 1/36,1/36,1/36,1/36];<br>cx = [ 0, 1, 0, -1, 0, 1, -1, -1, 1];<br>cy = [ 0, 0, 1, 0, -1, 1, 1, -1, -1];<br><br>tau=1;<br>mstep=5000;<br><br>G=-140;<br>psi0=4;<br>rho0=200;<br>delta_rho = 200+(1-2.0*rand(lx));<br>%初始化<br><br>u_x(lx,ly)=0;<br>u_y(lx,ly)=0;<br>u(lx,ly)=0;<br>v(lx,ly)=0;<br>ueq(lx,ly)=0;<br>veq(lx,ly)=0;<br><span class="hljs-keyword">for</span> k=1:9<br>fin(:,:,k)=w(k).*delta_rho;<br>end<br><br><span class="hljs-keyword">for</span> kk=1:mstep<br>tic<br><br>%计算宏观量<br><br>rho=<span class="hljs-built_in">sum</span>(fin,3);%计算每一点的密度<br><br><span class="hljs-keyword">for</span> i=1:lx<br><span class="hljs-keyword">for</span> j=1:ly<br>uSum=0;<br>vSum=0;<br><span class="hljs-keyword">for</span> k=1:9<br>uSum=uSum+fin(i,j,k)*cx(k);<br>vSum=vSum+fin(i,j,k)*cy(k);<br>end<br>u(i,j)=uSum/rho(i,j);%计算速度场<br>v(i,j)=vSum/rho(i,j);<br>end<br>end<br><br><span class="hljs-keyword">for</span> i=1:lx<br><span class="hljs-keyword">for</span> j=1:ly<br>psi(i,j)=4*exp(-rho0./rho(i,j));<br>end<br>end<br><br>Fx=zeros(lx,ly);<br>Fy=zeros(lx,ly);<br><br><span class="hljs-keyword">for</span> k=2:9<br>Fx=Fx+G.*psi.*w(k).*circshift(psi,[cx(k),cy(k),0]).*cx(k);<br>Fy=Fy+G.*psi.*w(k).*circshift(psi,[cx(k),cy(k),0]).*cy(k);<br>end<br><br>ueq=u+Fx*tau./rho;<br>veq=v+Fy*tau./rho;<br><br><br>%碰撞<br><span class="hljs-keyword">for</span> i=1:lx<br><span class="hljs-keyword">for</span> j=1:ly<br>t1=ueq(i,j)^2+veq(i,j)^2;<br><span class="hljs-keyword">for</span> k=1:9<br>t2=ueq(i,j)*cx(k)+veq(i,j)*cy(k);<br>feq(i,j,k)=rho(i,j)*w(k)*(1+3*t2+4.5*t2^2-1.5*t1);<br>fout(i,j,k) = fin(i,j,k) - 1/tau .* (fin(i,j,k)-feq(i,j,k));<br>end<br>end<br>end<br><br><span class="hljs-keyword">for</span> k=1:9<br>fin(:,:,k ) = circshift(fout(:,:,k ), [cx(k),cy(k),0]);<br>end<br><br><span class="hljs-keyword">if</span> mod(kk,1)==0<br>imagesc(fin(:,:,1 ));<br>axis off<br>axis equal<br>drawnow<br>end<br><br>toc<br>end<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>流体算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格子玻尔兹曼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CFD算法】伪势LBM模拟壁面接触角（python）</title>
    <link href="/2025/03/26/%E4%BC%AA%E5%8A%BF%E6%A8%A1%E5%9E%8B%EF%BC%88LBGK-EDM%EF%BC%89%E6%A8%A1%E6%8B%9F%E5%A3%81%E9%9D%A2%E6%8E%A5%E8%A7%A6%E8%A7%92%EF%BC%88python%EF%BC%89/"/>
    <url>/2025/03/26/%E4%BC%AA%E5%8A%BF%E6%A8%A1%E5%9E%8B%EF%BC%88LBGK-EDM%EF%BC%89%E6%A8%A1%E6%8B%9F%E5%A3%81%E9%9D%A2%E6%8E%A5%E8%A7%A6%E8%A7%92%EF%BC%88python%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="伪势模型（LBGK-EDM）模拟壁面接触角（Python-）"><a href="#伪势模型（LBGK-EDM）模拟壁面接触角（Python-）" class="headerlink" title="伪势模型（LBGK-EDM）模拟壁面接触角（Python ）"></a>伪势模型（LBGK-EDM）模拟壁面接触角（Python ）</h1><p>最近学习 LBM，把大佬给的 MATLAB 代码用 Python 重写了一遍。可以实现不同润湿性表面的接触角模拟以及粗糙表面接触角的模拟计算，采用的是伪势模型。</p><p>以下是实现效果：<br><img src="https://pic2.zhimg.com/v2-da95204e2f5bf3c6da76e7b1610a653d_1440w.jpg" alt="效果图1"><br><img src="https://pica.zhimg.com/v2-96c20a978cdfcfeb2eadfe2ee26d660c_1440w.jpg" alt="效果图2"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -*- coding:UTF-8 -*-</span><br><span class="hljs-comment"># Author:DABAIMENG</span><br><span class="hljs-comment"># Time:2023/7/14 8:00</span><br>from numpy import *<br>from matplotlib import cm<br>import matplotlib.pyplot as plt<br><br>np.set_printoptions(threshold=np.inf)<br></code></pre></td></tr></table></figure><h2 id="基本参数设置"><a href="#基本参数设置" class="headerlink" title="基本参数设置"></a>基本参数设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># LB 基本参数</span><br>G = -5.0<br>rho_liq = 1.95    <span class="hljs-comment"># 液体密度</span><br>rho_gas = 0.15    <span class="hljs-comment"># 气体密度</span><br>nx = 200          <span class="hljs-comment"># 定义计算尺寸</span><br>ny = 200<br>noput = 1<br><br><span class="hljs-comment"># 壁面密度，可调整 0.80 模拟不同亲疏水性</span><br>rho_boundary = rho_gas + 0.80 * (rho_liq - rho_gas)<br><br><span class="hljs-comment"># 粒子分布函数、平衡分布函数、速度分量分配内存</span><br>f = zeros((<span class="hljs-number">9</span>, nx, ny))<br>fx = zeros((<span class="hljs-number">9</span>, nx, ny))<br>feq = zeros((<span class="hljs-number">9</span>, nx, ny))<br>feq1 = zeros((<span class="hljs-number">9</span>, nx, ny))<br>u = zeros((nx, ny))<br>v = zeros((nx, ny))<br><br><span class="hljs-comment"># 修正速度分配内存</span><br>uf = zeros((nx, ny))<br>vf = zeros((nx, ny))<br>psi = zeros((nx, ny))       <span class="hljs-comment"># 势函数分配内存</span><br>forcx = zeros((nx, ny))     <span class="hljs-comment"># 外力项分配内存</span><br>forcy = zeros((nx, ny))<br>rho = rho_gas * ones((nx, ny))  <span class="hljs-comment"># 初始化密度为液体密度</span><br>pressure = zeros((nx, ny))<br>x = zeros(nx)<br>y = zeros(ny)<br></code></pre></td></tr></table></figure><h2 id="D2Q9-模型参数设置"><a href="#D2Q9-模型参数设置" class="headerlink" title="D2Q9 模型参数设置"></a>D2Q9 模型参数设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># D2Q9 模型参数设置</span><br>w = [1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36, 4/9]<br>opp = [2, 3, 0, 1, 6, 7, 4, 5, 8]<br>cx = [1, 0, -1, 0, 1, -1, -1, 1, 0]<br>cy = [0, 1, 0, -1, 1, 1, -1, -1, 0]<br>c2 = 1/3<br>omega = 1<br><br><span class="hljs-comment"># 液滴半径</span><br>Rd = 42<br>err = 10<br>counter = 1<br></code></pre></td></tr></table></figure><h2 id="壁面障碍物设定"><a href="#壁面障碍物设定" class="headerlink" title="壁面障碍物设定"></a>壁面障碍物设定</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 壁面障碍物设定</span><br>height_barrier = 10<br>obst = zeros((nx, ny))<br>obstk = zeros((<span class="hljs-number">9</span>, nx, ny))<br>a = 1<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nx):<br>    <span class="hljs-keyword">if</span> mod(i-5, 23) &lt; 3:<br>        obst[i-1, 0:height_barrier] = a<br>        obst[i-1, ny-height_barrier:ny] = a<br><br>obst[0:10, 0:height_barrier] = a<br>obst[0:10, ny-height_barrier:ny] = a<br>obst[nx-12:nx, 0:height_barrier] = a<br>obst[nx-12:nx, ny-height_barrier:ny] = a<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nx):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ny):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(8):<br>            <span class="hljs-keyword">if</span> j + cy[k] &lt; 0 or j + cy[k] &gt; ny-1:<br>                obstk[k, i, j] = 1<br>            <span class="hljs-keyword">elif</span> i + cx[k] &lt; 0 or i + cx[k] &gt; nx-1:<br>                obstk[k, i, j] = 2<br>            <span class="hljs-keyword">elif</span> obst[i + cx[k], j + cy[k]] == 1:<br>                obstk[k, i, j] = 1<br></code></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 初始化液滴</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nx):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ny):<br>        <span class="hljs-keyword">if</span> (i - nx/2)*(i - nx/2) + (j - Rd - 7)*(j - Rd - 7) &lt; Rd*Rd:<br>            rho[i, j] = rho_liq<br>        <span class="hljs-keyword">else</span>:<br>            rho[i, j] = rho_gas<br><br><span class="hljs-comment"># 计算初始压力</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ny):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nx):<br>        psi[i, j] = 1 - exp(-rho[i, j])<br>pressure = rho/3 + G * psi * psi/6<br></code></pre></td></tr></table></figure><h2 id="碰撞函数"><a href="#碰撞函数" class="headerlink" title="碰撞函数"></a>碰撞函数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">def collision(nx, ny, u, v, cx, cy, omega, f, rho, w, forcx, forcy):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nx):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ny):<br>            t1 = u[i, j] * u[i, j] + v[i, j] * v[i, j]<br>            t3 = (u[i, j] + omega * forcx[i, j] / rho[i, j]) * (u[i, j] + omega * forcx[i, j] / rho[i, j]) + (<br>                  v[i, j] + omega * forcy[i, j] / rho[i, j]) * (v[i, j] + omega * forcy[i, j] / rho[i, j])<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(9):<br>                t2 = u[i, j] * cx[k] + v[i, j] * cy[k]<br>                t4 = (u[i, j] + omega * forcx[i, j] / rho[i, j]) * cx[k] + (<br>                      v[i, j] + omega * forcy[i, j] / rho[i, j]) * cy[k]<br>                feq[k, i, j] = rho[i, j] * w[k] * (1.0 + 3.0 * t2 + 4.5 * t2 - 1.5 * t1)<br>                feq1[k, i, j] = rho[i, j] * w[k] * (1.0 + 3.0 * t4 + 4.5 * t4 - 1.5 * t3)<br>                f[k, i, j] = (1 - omega) * f[k, i, j] - (1 - omega) * feq[k, i, j] + feq1[k, i, j]<br>    <span class="hljs-built_in">return</span> f<br></code></pre></td></tr></table></figure><h2 id="外力计算函数"><a href="#外力计算函数" class="headerlink" title="外力计算函数"></a>外力计算函数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">def force(nx, ny, cx, cy, rho, rho_boundary, rho_liq, rho_gas, w, G, obstk):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(nx):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(ny):<br>            forcxs = 0.0<br>            forcys = 0.0<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(8):<br>                newx = i + cx[k]<br>                newy = j + cy[k]<br>                <span class="hljs-keyword">if</span> obstk[k, i, j] == 1:<br>                    <span class="hljs-keyword">if</span> rho[i, j] &gt; rho_liq / 8:<br>                        psi[i, j] = 1 - exp(-rho_boundary)<br>                        forcxs = forcxs - w[k] * G * psi[i, j] * cx[k]<br>                        forcys = forcys - w[k] * G * psi[i, j] * cy[k]<br>                    <span class="hljs-keyword">else</span>:<br>                        psi[i, j] = 1 - exp(-rho_gas)<br>                        forcxs = forcxs - w[k] * G * psi[i, j] * cx[k]<br>                        forcys = forcys - w[k] * G * psi[i, j] * cy[k]<br>                <span class="hljs-keyword">elif</span> obstk[k, i, j] == 2:<br>                    psi[i, j] = 1 - exp(-rho[i, j])<br>                    forcxs = forcxs - w[k] * G * psi[i, j] * cx[k]<br>                    forcys = forcys - w[k] * G * psi[i, j] * cy[k]<br>                <span class="hljs-keyword">else</span>:<br>                    psi[i, j] = 1 - exp(-rho[newx, newy])<br>                    forcxs = forcxs - w[k] * G * psi[i, j] * cx[k]<br>                    forcys = forcys - w[k] * G * psi[i, j] * cy[k]<br>            forcx[i, j] = (1 - exp(-rho[i, j])) * forcxs<br>            forcy[i, j] = (1 - exp(-rho[i, j])) * forcys<br>    <span class="hljs-built_in">return</span> forcx, forcy, psi<br></code></pre></td></tr></table></figure><h2 id="宏观参数计算函数"><a href="#宏观参数计算函数" class="headerlink" title="宏观参数计算函数"></a>宏观参数计算函数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">def ruv(u, v, f, psi, rho, obst):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nx):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ny):<br>            <span class="hljs-keyword">if</span> obst[i, j] == 0:<br>                rho[i, j] = <span class="hljs-built_in">sum</span>(f[:, i, j], axis=0)<br>                u[i, j] = (<span class="hljs-built_in">sum</span>(f[[0, 4, 7], i, j], axis=0) - <span class="hljs-built_in">sum</span>(f[[2, 5, 6], i, j], axis=0)) / rho[i, j]<br>                v[i, j] = (<span class="hljs-built_in">sum</span>(f[[1, 4, 5], i, j], axis=0) - <span class="hljs-built_in">sum</span>(f[[3, 6, 7], i, j], axis=0)) / rho[i, j]<br>                pressure = rho[i, j] / 3 + 1.5 * G * psi[i, j] * psi[i, j]<br>            <span class="hljs-keyword">else</span>:<br>                rho[i, j] = nan<br>                u[i, j] = nan<br>                v[i, j] = nan<br>    <span class="hljs-built_in">return</span> rho, u, v, pressure<br></code></pre></td></tr></table></figure><h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">def boundary(nx, ny, f, f_old, obstk, opp, obst):<br>    fx = np.array(f, copy=True)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nx):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ny):<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(8):<br>                <span class="hljs-keyword">if</span> obstk[k, i, j] == 1:<br>                    fx[opp[k], i, j] = f_old[k, i, j]<br>    fx1 = np.array(fx, copy=True)<br>    fx2 = np.array(fx, copy=True)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ny):<br>        <span class="hljs-keyword">if</span> obst[1, j] == 0:<br>            fx2[0, 0, j] = fx1[0, nx-1, j]<br>            fx2[4, 0, j] = fx1[4, nx-1, j]<br>            fx2[7, 0, j] = fx1[7, nx-1, j]<br>            fx2[2, nx-1, j] = fx1[2, 0, j]<br>            fx2[5, nx-1, j] = fx1[5, 0, j]<br>            fx2[6, nx-1, j] = fx1[6, 0, j]<br>    <span class="hljs-built_in">return</span> fx2, fx1<br></code></pre></td></tr></table></figure><h2 id="迁移项"><a href="#迁移项" class="headerlink" title="迁移项"></a>迁移项</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">def stream(f):<br>    f_old = np.array(f, copy=True)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(9):<br>        f[i, :, :] = roll(roll(f[i, :, :], cx[i], axis=0), cy[i], axis=1)<br>    <span class="hljs-built_in">return</span> f, f_old<br><br>def uvf(u, v, forcx, forcy, rho):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nx):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ny):<br>            uf[i, j] = u[i, j] + omega * forcx[i, j] / (2 * rho[i, j])<br>            vf[i, j] = v[i, j] + omega * forcy[i, j] / (2 * rho[i, j])<br>    <span class="hljs-built_in">return</span> uf, vf<br></code></pre></td></tr></table></figure><h2 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">counter = 1<br><span class="hljs-keyword">while</span> counter &lt; 1000:<br>    err = 0<br>    forcx, forcy, psi = force(nx, ny, cx, cy, rho, rho_boundary, rho_liq, rho_gas, w, G, obstk)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;碰撞%s&#x27;</span> % counter)<br>    f = collision(nx, ny, u, v, cx, cy, omega, f, rho, w, forcx, forcy)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;迁移%s&#x27;</span> % counter)<br>    f, f_old = stream(f)<br>    f, fill = boundary(nx, ny, f, f_old, obstk, opp, obst)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;宏观量计算%s&#x27;</span> % counter)<br>    rho, u, v, pressure = ruv(u, v, f, psi, rho, obst)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;速度修正%s&#x27;</span> % counter)<br>    uf, vf = uvf(u, v, forcx, forcy, rho)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;***********&#x27;</span>)<br>    rho_tot = 0<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nx):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ny):<br>            <span class="hljs-keyword">if</span> rho[i, j] != <span class="hljs-string">&#x27;&#x27;</span>:<br>                rho_tot = rho_tot + rho[i, j]<br>    <span class="hljs-built_in">print</span>(rho_tot)<br>    plt.imshow(rho, cmap=cm.bwr)<br>    plt.savefig(r<span class="hljs-string">&quot;./计算结果/&quot;</span> + str(counter) + <span class="hljs-string">&quot;.png&quot;</span>)<br>    plt.clf()<br>    counter = counter + 1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>流体算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格子玻尔兹曼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【自制仪器】制作二氧化碳监测平台</title>
    <link href="/2025/03/12/%E8%87%AA%E5%88%B6%E4%BA%8C%E6%B0%A7%E5%8C%96%E7%A2%B3%E7%9B%91%E6%B5%8B%E5%B9%B3%E5%8F%B0/"/>
    <url>/2025/03/12/%E8%87%AA%E5%88%B6%E4%BA%8C%E6%B0%A7%E5%8C%96%E7%A2%B3%E7%9B%91%E6%B5%8B%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="ESP32（Arduino）-SGP30-ThingsPanel实现远程CO2-TVOC监测"><a href="#ESP32（Arduino）-SGP30-ThingsPanel实现远程CO2-TVOC监测" class="headerlink" title="ESP32（Arduino）+SGP30+ThingsPanel实现远程CO2+TVOC监测"></a>ESP32（Arduino）+SGP30+ThingsPanel实现远程CO2+TVOC监测</h1><p>最近学习单片机，发现一个开源的物联网平台，虽然功能不是很完善，但完全够用。把自己目前做的记录一下。实现效果如下图（数据看板以及设备定位，坐标是我随便写的）：</p><p><img src="https://pic3.zhimg.com/v2-26567130a6f6b7aab911ec41e1b0f7b2_1440w.jpg" alt="效果图1"></p><p><img src="https://pic3.zhimg.com/v2-b03641c6aae7663c466b1b4732a24662_1440w.jpg" alt="效果图2"></p><p>主要参考官网给的8266的例子，将代码略微改动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;Wire.h&gt;</span><br><span class="hljs-comment">#include &lt;Adafruit_SGP30.h&gt;</span><br><span class="hljs-comment">#include &lt;WiFi.h&gt;</span><br><span class="hljs-comment">#include &lt;PubSubClient.h&gt;</span><br><span class="hljs-comment">#include &lt;ArduinoJson.h&gt;</span><br><br>StaticJsonDocument&lt;200&gt; doc;<br>Adafruit_SGP30 sgp;<br><br>// WiFi和MQTT设置<br>const char *ssid = <span class="hljs-string">&quot;要连接的wifi名&quot;</span>;<br>const char *password = <span class="hljs-string">&quot;WiFi密码&quot;</span>;<br>const char* mqtt_server = <span class="hljs-string">&quot;参考官网&quot;</span>;<br>const char* mqtt_user = <span class="hljs-string">&quot;参考官网&quot;</span>;<br>const char* mqtt_password = <span class="hljs-string">&quot;&quot;</span>; // 密码为空<br>const char* mqtt_topic = <span class="hljs-string">&quot;参考官网&quot;</span>;<br><br>WiFiClient espClient;<br>PubSubClient client(espClient);<br><br>void <span class="hljs-function"><span class="hljs-title">setup</span></span>() &#123;<br>    Serial.begin(9600);<br><br>    // 连接WiFi<br>    WiFi.begin(ssid, password);<br>    <span class="hljs-keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;<br>        delay(1000);<br>        Serial.println(<span class="hljs-string">&quot;连接WiFi...&quot;</span>);<br>    &#125;<br>    Serial.println(<span class="hljs-string">&quot;已连接到WiFi&quot;</span>);<br><br>    client.setServer(mqtt_server, 1883);<br><br>    <span class="hljs-keyword">if</span> (!sgp.begin())&#123;<br>        Serial.println(<span class="hljs-string">&quot;Failed to initialize SGP30 sensor.&quot;</span>);<br>        <span class="hljs-keyword">while</span> (1);<br>    &#125;<br>    sgp.begin();<br>    Serial.println(<span class="hljs-string">&quot;SGP30 sensor initialized.&quot;</span>);<br>&#125;<br><br>void <span class="hljs-function"><span class="hljs-title">loop</span></span>() &#123;<br>    <span class="hljs-keyword">if</span> (!client.connected()) &#123;<br>        reconnect();<br>    &#125;<br>    client.loop();<br><br>    <span class="hljs-keyword">if</span> (!sgp.IAQmeasure()) &#123;<br>        Serial.println(<span class="hljs-string">&quot;Measurement failed.&quot;</span>);<br>        <span class="hljs-built_in">return</span>;<br>    &#125;<br><br>    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;eCO2: &quot;</span>);<br>    Serial.<span class="hljs-built_in">print</span>(sgp.eCO2);<br>    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; ppm\t&quot;</span>);<br>    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;TVOC: &quot;</span>);<br>    Serial.<span class="hljs-built_in">print</span>(sgp.TVOC);<br>    Serial.println(<span class="hljs-string">&quot; ppb&quot;</span>);<br><br>    // 使用ArduinoJson生成MQTT消息<br>    StaticJsonDocument&lt;100&gt; doc;<br>    doc[<span class="hljs-string">&quot;eco2&quot;</span>] = sgp.eCO2;<br>    doc[<span class="hljs-string">&quot;tvoc&quot;</span>] = sgp.TVOC;<br>    char payload[100];<br>    serializeJson(doc, payload);<br>    client.publish(mqtt_topic, payload);<br><br>    delay(1000 * 5); // 1秒<br>&#125;<br><br>void <span class="hljs-function"><span class="hljs-title">reconnect</span></span>() &#123;<br>    <span class="hljs-keyword">while</span> (!client.connected()) &#123;<br>        Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;尝试MQTT连接...&quot;</span>);<br>        <span class="hljs-keyword">if</span> (client.connect(<span class="hljs-string">&quot;ESP32Client&quot;</span>, mqtt_user, mqtt_password)) &#123;<br>            Serial.println(<span class="hljs-string">&quot;已连接&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;失败, rc=&quot;</span>);<br>            Serial.<span class="hljs-built_in">print</span>(client.state());<br>            Serial.println(<span class="hljs-string">&quot; 5秒后再试&quot;</span>);<br>            delay(5000);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中关于WiFi和MQTT设置大家参考官网文章：</p><p><a href="https://link.zhihu.com/?target=http://www.thingspanel.cn/posts/64">ThingsPanel官网文章</a></p><p>硬件连接部分：准备一个ESP32，一个SGP30传感器，四根杜邦线。</p><p><img src="https://pica.zhimg.com/v2-a463b21c1a5069ad76cfbd22ad00ec62_1440w.jpg" alt="硬件连接图1"></p><p><img src="https://pic3.zhimg.com/v2-0237b429ace772af0c73660eddad631c_1440w.jpg" alt="硬件连接图2"></p><p>可以监测任何网络覆盖区域的CO2与TVOC值，所有数据实时传输到本地平台。下面是我用Python写的一个串口监视，用于本机监控（用了非常笨拙的方法）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -*- coding:UTF-8 -*-</span><br><span class="hljs-comment"># Author:DA BAIMENG</span><br><span class="hljs-comment"># Time:2023/9/15 15:46</span><br><br>import <span class="hljs-keyword">time</span><br>import serial<br>import re<br>import datetime<br>import sys<br>import matplotlib.pyplot as plt<br>import keyboard<br>from matplotlib.animation import FuncAnimation<br><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]<br><br>arduino = serial.Serial(<span class="hljs-string">&quot;COM5&quot;</span>)<br>CO2 = []<br>TVOC = []<br>time1 = []<br>count = 0<br><br><span class="hljs-keyword">while</span> True:<br>    <span class="hljs-comment"># time.sleep(1)</span><br>    <span class="hljs-comment"># time2 = datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br>    <span class="hljs-comment"># time1.append(time2)</span><br>    <span class="hljs-comment"># file = open(&#x27;data.csv&#x27;, &#x27;w&#x27;)</span><br>    <span class="hljs-comment"># file.write(str(CO2) + &#x27;\n&#x27;)</span><br>    <span class="hljs-comment"># file.write(str(TVOC) + &#x27;\n&#x27;)</span><br>    <span class="hljs-comment"># file.write(str(time1) + &#x27;\n&#x27;)</span><br><br>    bytes_data = arduino.readline()<br>    string_data = bytes_data.decode(<span class="hljs-string">&#x27;gbk&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(str(string_data))<br>    count = count + 1<br><br>    <span class="hljs-keyword">if</span> count &gt;= 5:<br>        try:<br>            values = re.finditer(r<span class="hljs-string">&#x27;\d+&#x27;</span>, string_data) <span class="hljs-comment">#获取字符串中的数字</span><br>            s1 = []<br>            <span class="hljs-keyword">for</span> match <span class="hljs-keyword">in</span> values:<br>                s1.append(match.group())#将获取的数字加入临时列表<br>            CO2.append(int(s1[1]))<br>            TVOC.append(int(s1[2]))<br><br>            <span class="hljs-comment"># 绘制图形</span><br>            plt.clf()<br>            plt.subplot(2, 1, 1)<br>            plt.plot(CO2)<br>            plt.ylabel(<span class="hljs-string">&quot;CO2浓度 / ppm&quot;</span>)<br>            plt.subplot(2, 1, 2)<br>            plt.plot(TVOC)<br>            plt.ylabel(<span class="hljs-string">&quot;TVOC浓度 / ppb&quot;</span>)<br><br>            <span class="hljs-comment"># 不显示图形</span><br>            plt.ioff()<br><br>            <span class="hljs-comment"># 更新图形</span><br>            plt.pause(0.01)<br>        except :<br>            <span class="hljs-built_in">break</span><br></code></pre></td></tr></table></figure><p>效果：<br><a href="https://zhuanlan.zhihu.com/p/663194646">知乎原文</a></p>]]></content>
    
    
    <categories>
      
      <category>硬件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【自制仪器】制作一台扫描隧道显微镜[一]</title>
    <link href="/2025/03/12/%E8%87%AA%E5%88%B6%E6%89%AB%E6%8F%8F%E9%9A%A7%E9%81%93%E6%98%BE%E5%BE%AE%E9%95%9C%E3%80%90%E4%B8%80%E3%80%91/"/>
    <url>/2025/03/12/%E8%87%AA%E5%88%B6%E6%89%AB%E6%8F%8F%E9%9A%A7%E9%81%93%E6%98%BE%E5%BE%AE%E9%95%9C%E3%80%90%E4%B8%80%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="自制一个扫描隧道显微镜【一】"><a href="#自制一个扫描隧道显微镜【一】" class="headerlink" title="自制一个扫描隧道显微镜【一】"></a>自制一个扫描隧道显微镜【一】</h1><p>在B站上看到的超牛UP，采用3D打印技术制作了一个扫描隧道显微镜，并测到了石墨的原子结构。项目已经开源了，看完后按耐不住躁动的心，准备复刻一个，目前完成度50%，由于条件限制，有些工作开展的比较费劲，希望能够完成吧。</p><p>UP@机械小熊猫 扫描得到的石墨原子结构（实际应该是电子云密度）：</p><p><img src="https://pic4.zhimg.com/v2-a79e025948b7cb45b228328ea98e489d_1440w.jpg" alt="石墨原子结构"></p><p>下面是我目前的进度。</p><p>主要解决三大块内容：要完成纳米级精度扫描要求的扫描台、处理pA级电流的前置放大电路与控制电路、固件程序与软件开发。</p><h2 id="3D打印的主体和减震平台"><a href="#3D打印的主体和减震平台" class="headerlink" title="3D打印的主体和减震平台"></a>3D打印的主体和减震平台</h2><p><img src="https://pic4.zhimg.com/v2-f123343a9d69088a7410116e1473f1a7_1440w.jpg" alt="整体模型"></p><p><img src="https://picx.zhimg.com/v2-f98d74e6317db3ddd64cd7b1287a217f_1440w.jpg" alt="3D打印零件"></p><p><img src="https://pic3.zhimg.com/v2-8787df67414e4ffb8c1957d2db28b580_1440w.jpg" alt="组装零件、安装紧固件、贴铝胶带、固定电机"></p><p><img src="https://picx.zhimg.com/v2-c8073282d7b76febe85058a8c981a5eb_1440w.jpg" alt="扫描台主体"></p><p><img src="https://pic4.zhimg.com/v2-0f366ff2f803b7910abcfca7fc6062bb_1440w.jpg" alt="减震平台"></p><p>斥巨资买了四个索雷博的精细调节螺丝，与步进电机结合可以达到微米级精度的控制。</p><p><img src="https://pic4.zhimg.com/v2-e42a76df64ff68fdc2ae050592b34281_1440w.jpg" alt="精细调节螺丝"></p><p>买的FAS100 搭配四个铜套：</p><p><img src="https://picx.zhimg.com/v2-639d074e9a72af4b6d0b0544e6083b85_1440w.jpg" alt="FAS100"></p><p><img src="https://pic2.zhimg.com/v2-b7b45a6b2c92a0488b72fb4383a2193d_1440w.jpg" alt="铜套"></p><h2 id="手工焊接扫描头"><a href="#手工焊接扫描头" class="headerlink" title="手工焊接扫描头"></a>手工焊接扫描头</h2><p>采用压电陶瓷片提供纳米级精度的控制：</p><p><img src="https://pica.zhimg.com/v2-5eb476adb842b24abbb2b29901a89a4c_1440w.jpg" alt="压电陶瓷片"></p><p>压电陶瓷拆分成四部分，可以进行面扫描：</p><p><img src="https://pic1.zhimg.com/v2-4e1201f6f0ad129892daaa56a7c51dec_1440w.jpg" alt="压电陶瓷拆分"></p><p>扫描头由拆开的DIP引脚焊接而成。</p><h2 id="定做前置放大器和控制电路"><a href="#定做前置放大器和控制电路" class="headerlink" title="定做前置放大器和控制电路"></a>定做前置放大器和控制电路</h2><p>（开源文件里没有物料表，所以我将PCB中的所有元器件进行了重新标记，参考了另一位大神的开源资料扫描隧道显微镜OpenSTM - 立创开源硬件平台。前置放大器参考了Dan Berard提供的开源板，详情参考<a href="https://dberard.com/home-built-stm/">Dan Berard的网站</a>。）</p><p><img src="https://pic3.zhimg.com/v2-44d8b927193d3608bd653256405f99bc_1440w.jpg" alt="控制电路DAC部分"></p><p><img src="https://picx.zhimg.com/v2-50697aca3648f848fed9c9c0e379bbc7_1440w.jpg" alt="控制电路PCB"></p><p><img src="https://pica.zhimg.com/v2-ceb3939056d31caa6f167cd15a17dc74_1440w.jpg" alt="前置放大器"></p><p>小的是前置放大器、大的是控制电路：</p><p><img src="https://pic1.zhimg.com/v2-d673903e2439c10bc20adef23ab1168e_1440w.jpg" alt="前置放大器和控制电路"></p><h2 id="固件与软件"><a href="#固件与软件" class="headerlink" title="固件与软件"></a>固件与软件</h2><p>（这部分全部用的开源代码，看了很久，大概了解怎么跑起来的了。）</p><p><img src="https://pic4.zhimg.com/v2-90c9079ce6b36c903132ae928b4c416d_1440w.jpg" alt="teensy4.1单片机搭配Adurino IDE"></p><p><img src="https://pic3.zhimg.com/v2-a544a96b29abc8402d486663af34774a_1440w.jpg" alt="控制界面采用python+tkinter"></p><p>接下来要连接各部分的线路，有后续再更新。</p>]]></content>
    
    
    <categories>
      
      <category>硬件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【教程】本地部署DeepSeek指南</title>
    <link href="/2025/02/12/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2DeepSeek%E6%8C%87%E5%8D%97/"/>
    <url>/2025/02/12/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2DeepSeek%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="本地部署DeepSeek指南"><a href="#本地部署DeepSeek指南" class="headerlink" title="本地部署DeepSeek指南"></a>本地部署DeepSeek指南</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DeepSeek是一款强大的自然语言处理工具，广泛应用于信息检索、文本分析等领域。本文将详细介绍如何在本地环境中部署DeepSeek，以便开发者能够更高效地利用这一工具。</p><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>在开始部署之前，请确保系统满足以下环境要求：</p><ul><li>操作系统：Linux或Windows</li><li>CPU：至少4核</li><li>内存：至少8GB</li><li>硬盘：至少100GB可用空间</li><li>Python：3.6及以上版本</li><li>其他依赖：Git、CMake、GCC</li></ul><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><h3 id="1-克隆DeepSeek仓库"><a href="#1-克隆DeepSeek仓库" class="headerlink" title="1. 克隆DeepSeek仓库"></a>1. 克隆DeepSeek仓库</h3><p>首先，需要从GitHub上克隆DeepSeek的源代码仓库。打开终端或命令提示符，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/deepseek/deepseek.git<br><span class="hljs-built_in">cd</span> deepseek<br></code></pre></td></tr></table></figure><h3 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2. 安装依赖"></a>2. 安装依赖</h3><p>DeepSeek依赖于多个Python库和系统工具。可以使用以下命令安装所需的Python库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -r requirements.txt<br></code></pre></td></tr></table></figure><p>对于系统工具，请根据操作系统进行安装。例如，在Ubuntu上可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/deepseek/deepseek.git<br><span class="hljs-built_in">cd</span> deepseek<br></code></pre></td></tr></table></figure><h3 id="3-编译源代码"><a href="#3-编译源代码" class="headerlink" title="3. 编译源代码"></a>3. 编译源代码</h3><p>DeepSeek的部分组件需要编译。进入src目录，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake ..<br>make<br></code></pre></td></tr></table></figure><p>编译过程可能需要一些时间，请耐心等待。</p><h3 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4. 配置环境变量"></a>4. 配置环境变量</h3><p>为了方便使用DeepSeek，建议将其添加到环境变量中。编辑<del>&#x2F;.bashrc或</del>&#x2F;.zshrc文件，添加以下行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> DEEPSEEK_PATH=/path/to/deepseek<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$DEEPSEEK_PATH</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>保存并关闭文件，然后执行source ~&#x2F;.bashrc或source ~&#x2F;.zshrc使更改生效。</p><h3 id="5-初始化数据库"><a href="#5-初始化数据库" class="headerlink" title="5. 初始化数据库"></a>5. 初始化数据库</h3><p>DeepSeek使用数据库存储索引和数据。需要初始化数据库。执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">deepseek_init_db<br></code></pre></td></tr></table></figure><h3 id="6-导入数据"><a href="#6-导入数据" class="headerlink" title="6. 导入数据"></a>6. 导入数据</h3><p>如果已有数据需要导入DeepSeek，可以使用deepseek_import命令。例如，导入一个CSV文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">deepseek_import data.csv<br></code></pre></td></tr></table></figure><h3 id="7-启动DeepSeek服务"><a href="#7-启动DeepSeek服务" class="headerlink" title="7. 启动DeepSeek服务"></a>7. 启动DeepSeek服务</h3><p>一切准备就绪后，可以启动DeepSeek服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">deepseek_start<br></code></pre></td></tr></table></figure><p>服务启动后，DeepSeek将开始监听指定端口，等待客户端请求。</p><h2 id="测试DeepSeek"><a href="#测试DeepSeek" class="headerlink" title="测试DeepSeek"></a>测试DeepSeek</h2><p>为了确保DeepSeek正确部署，可以进行简单的测试。使用以下命令发送查询请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">deepseek_query <span class="hljs-string">&quot;您的查询内容&quot;</span><br></code></pre></td></tr></table></figure><p>如果一切正常，将看到与查询内容相关的结果。</p>]]></content>
    
    
    <categories>
      
      <category>AI算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deepseek</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello！ Welcome to DABAI MENG&#39;s blog</title>
    <link href="/2025/02/08/hello-world/"/>
    <url>/2025/02/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到大白锰的博客，在这里我将记录一些随笔和技术文章，请随意浏览。</p><p>这个网站采用Hexo框架搭建，并托管在GitHub平台上。</p><p>欢迎使用<a href="https://hexo.io/">Hexo</a>！查看文档以获取更多信息。在使用Hexo时遇到任何问题，你可以在<a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a>中找到答案，或者你可以在<a href="https://github.com/hexojs/hexo/issues">GitHub</a>上提问。</p><p>Welcome to the blog of Dabaimeng, where I will record some essays and technical articles. Feel free to browse.</p><p>This website is built with the Hexo framework and hosted on GitHub.</p><p>Welcome to use <a href="https://hexo.io/">Hexo</a>! Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask with <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
